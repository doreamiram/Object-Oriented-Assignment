from abc import ABC, abstractmethod

# --- הגדרות המחלקות (סעיף א + ג) ---

class Animal(ABC): # מחלקה אבסטרקטית טהורה 
    @abstractmethod
    def speak(self):
        pass

class Dog(Animal): # ירושה מהמחלקה האבסטרקטית 
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

# --- החלק המריץ (Main) ---

if __name__ == "__main__":
    # יצירת הרשימה כפי שמופיע בשאלה [cite: 17]
    animals = [Dog(), Cat(), "I am not an animal"] 

    for animal in animals:
        # בדיקה האם האובייקט הוא מסוג Animal לפני הקריאה למתודה 
        if isinstance(animal, Animal):
            print(animal.speak())
        else:
            print(f"Skipping: {animal} is not a valid Animal type")

""""
*יש בקובץ וורד נפרד את התשובות העיוניות בצורה מסודרת
ב. "נראה כמו ברווז ומגעגע כמו ברווז... הוא ברווז"
הכוונה בביטוי זה היא שפייתון היא שפה עם טיפוסיות דינמית. בניגוד לשפות קשיחות, בפייתון לא תמיד מעניין אותנו מהו ה"סוג" (Class) המדויק של האובייקט, אלא האם הוא מממש את ההתנהגות הנדרשת.

אם לאובייקט יש מתודה בשם speak(), הלולאה תפעיל אותה בלי לבדוק אם הוא "כלב" או "חתול".

ה"סוג" נקבע לפי היכולות של האובייקט בזמן ריצה.

ד. מטרת הרב-צורתיות ותוצאתה
המטרה: לאפשר לממשק אחד (למשל, הקריאה ל-speak()) לייצג צורות עבודה שונות עבור סוגי נתונים שונים. זה מאפשר לכתוב קוד גנרי שלא צריך לדעת מראש איזה אובייקט הוא מקבל, כל עוד האובייקט תומך בפעולה הנדרשת.
התוצאה: קוד גמיש יותר, קל לתחזוקה וניתן להרחבה (Scalable).
 לדוגמה, אם נוסיף בעתיד מחלקת 
 Cow, לא נצטרך לשנות את הלולאה המרכזית, היא פשוט תעבוד.
"""


